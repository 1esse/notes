# 排序

## 稳定性（p228）
1. 稳定：若在排序后相同记录的元素**索引前后位置**不发生改变，则称所用的排序方法是稳定的
2. 不稳定：若在排序后相同记录的元素**索引前后位置**发生改变，则称所用的排序方法是不稳定的

## 插入排序（p229）
基本思想：每一趟将一个待排序的记录，按其关键字的大小插入已经排好序的一组记录的适当位置，直到所有待排序记录全部插入为止。

### 直接插入排序
直接插入排序是一种最简单的排序方法，其基本操作是将一条记录插入已排好序的表，从而得到一个新的，记录数量增1的有序表。

要点：
1. 稳定性：稳定排序
2. $时间复杂度：O(n^2)$
3. $空间复杂度：O(1)$
4. 适用性：适用于链式存储结构，在单链表上无需移动记录，只需修改相应的指针。更适合于初始记录基本有序的情况。当初始记录无序，n较大时，此算法时间复杂度较高，不宜采用。

### 折半插入排序
直接插入排序采用顺序查找法查找当前记录在已排好序的序列中的插入位置，这个查找操作利用折半查找来实现，由此进行的插入排序称之为折半插入排序。

要点：
1. 稳定性：稳定排序
2. $时间复杂度：O(n^2)$
3. $空间复杂度：O(1)$
4. 适用性：因为要进行折半查找，所以只能用于顺序结构，不能用于链式结构。适合初始记录无序，n较大的情况。

### 希尔排序
希尔排序又称“缩小增量排序”，是插入排序的一种，因D.L.Shell于1959年提出而得名。当待排序的记录个数较少且待排序序列的关键字基本有序时，直接插入排序效率较高。希尔排序基于以上两点，从“减少记录个数”和“序列基本有序”两个方面对直接插入排序进行了改进。

希尔排序采用分组插入的方法，先将整个待排序记录序列分割成几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。这样当经过几次分组排序后，整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。

要点：
1. 稳定性：不稳定排序
2. $时间复杂度：不确定$
3. $空间复杂度：O(1)$
4. 适用性：记录总的比较次数和移动次数都比直接插入排序要少，n越大时，效果越明显。所以适合初始记录无序，n较大时的情况。

## 交换排序（p234）
基本思想：两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，直到整个序列全部满足要求为止。

### 冒泡排序
冒泡排序是一种最简单的交换排序方法，它通过两两比较相邻记录的关键字，如果为逆序，则进行交换，从而使关键字小的记录如气泡一般逐渐往上“漂浮”（左移），或者使关键字大的记录如石块一样逐渐向下“坠落”（右移）。

要点：
1. 稳定性：稳定排序
2. $时间复杂度：O(n^2)$
3. $空间复杂度：O(1)$
4. 适用性：移动记录次数较多，算法的平均时间性能比直接插入排序的差。当初始记录无序，n较大时，此算法不宜采用。

### 快速排序
快速排序是由冒泡排序改进的。在冒泡排序过程中，只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序排列。如果能通过两个（不相邻）记录的一次交换，消除多个逆序排列，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序排列。

要点：
1. 稳定性：不稳定排序
2. $时间复杂度：O(n\log_2n)（最坏情况为O(n^2)）$
3. $空间复杂度：O(n)$
4. 适用性：排序过程中需要定位表的下界和上界，所以适用于顺序结构，很难用于链式结构。当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适合初始记录无序，n较大的情况。

## 选择排序（p239）
基本思想：每一趟从待排序的记录中选出关键字最小的记录，按顺序将其放在已排好序的记录序列的最后，直到全部排完为止。

### 简单选择排序（直接选择排序）
要点：
1. 稳定性：稳定排序
2. $时间复杂度：O(n^2)$
3. $空间复杂度：O(1)$
4. 适用性：可用于链式存储结构。移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。

### 堆排序
堆排序是一种树形选择排序，在排序过程中，将待排序的记录r[1..n]看成一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序的序列中选择关键字最大（或最小）的记录。

要点：
1. 稳定性：不稳定排序
2. $时间复杂度：O(n\log_2n)$
3. $空间复杂度：O(1)$
4. 适用性：只能用于顺序结构，不能用于链式结构。初始建堆所需的比较次数较多，因此记录数较少时不宜采用。最坏情况下时间复杂度相对于快速排序更有优势，当记录较多时较为高效。

## 归并排序
基本思想：假设初始序列含有n个记录，则可将其看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列；再两两归并，如此重复，直至得到一个长度为n的有序序列为止。

归并排序就是将两个或两个以上的有序表合并成一个有序表的过程。将两个有序表合并成一个有序表的过程称为**2-路归并**，2-路归并最为简单和常用。

要点：
1. 稳定性：稳定排序
2. $时间复杂度：O(n\log_2n)$
3. $空间复杂度：O(n)$
4. 适用性：可用于链式结构，且不需要附加存储空间，但递归实现时仍需要开辟相应的递归工作栈。

## 基数排序
前面各类排序方法都建立在关键字比较的基础上，而分配类排序不需要比较关键字的大小，它是根据关键字中各位的值，通过对待排序记录进行若干趟“分配”与“收集”来实现排序的，是一种借助于多关键字排序的思想对单关键字进行排序的方法。基数排序是典型的分配类排序。

### 链式基数排序
要点：
1. 稳定性：稳定排序
2. $时间复杂度：O(d(n+rd))$
3. $空间复杂度：O(n+rd)$
4. 适用性：可用于链式结构，也可用于顺序结构。时间复杂度可以突破给予关键字比较一类方法的下界O(nlog_2n)，达到O(n)。但基数排序的使用有严格的要求，需要知道各级关键字的主次关系和各级关键字的取值范围。
